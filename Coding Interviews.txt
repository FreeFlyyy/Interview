一 如何介绍项目
    Situation   : 简短的项目背景，如功能，规模，目标用户。
    Task        : 完成了项目中哪些部分的开发。
    Action      : 通过什么技术来进行开发的。
    Resualt     : 自己的贡献，修改了多少个bug，提高了性能，完成了多少功能。
    项目中最大的问题，如何解决的。
    在项目中学到了什么。

二 面试的技术考察
    1.基础知识
        主要是编程语言 数据结构 算法。
    2.高质量代码
        应该注意边界条件，特殊输入。
    3.优化能力

三 提问
    1.薪水工资不问。
    2.结果不问，否则显得没有自我评估能力，而且一般都是白问。
    3.问和应聘职务挂钩的事情。

四 题目
    1.多线程下的单例模式实现
        1).不能延迟初始化
            class A{
                private static A instance = new A();
                public static A getInstance(){ return instance; }
            }
        2).利用同步机制
            class A{
                private static A instance;
                public static A getInstance(){ 
                    if(instance == null){
                        synchronized(this){
                            if(instance == null){
                                instance = new A();
                            }
                        }
                    }
                    return instance;
                }
            }
        3).利用嵌套类
            class A{
                static public A getInstance(){
                    return B.unique;
                }
                
                private static class B{
                    static private final A unique = new A();
                }
            }
    2.二维数组中的查找：每一行都是按照从左到右递增，每一列都是按照从上到下递增。输入一个整数，判断是否存在该整数。
    3.替换空格。
    4.从尾到头打印链表。
    5.根据前序 中序遍历的结果，重建二叉树。
    6.用两个栈实现队列。用两个队列实现栈。
    7.求旋转数组的最小值。
    8.求斐波那契数列、青蛙跳台阶。
    9.二进制中1的个数。n&(n-1)的结果是n的最右边的1置为0。
    10.数值的整数次方。主要是考虑输入的合法性以及将整数次方的多次乘法化为更少的操作。
    11.打印1到最大的n位数。主要考察大数问题。
    12.O(1)时间删除链表中的节点。
    13.调整数组顺序，将奇数放在偶数前。
    14.链表倒数第k个节点
    15.反转链表。
    16.合并两个排序的链表。
    17.输入两棵二叉树A和B，判断B是否为A的子结构。
    18.二叉树镜像
    19.顺时针打印矩阵
    20.包含min函数的栈
    21.已知栈的压入序列，判断弹出序列是否合法。
    22.从上往下打印二叉树。
    23.判断一串序列是否为指定树的后续遍历序列。
    24.输入一个二叉树和某个值，找出树中结点值之和为该值的所有路径。
    25.复杂链表的复制。
    26.将二叉树结构转为双向链表。要求不能创建任何新节点。递归，创建当前树的链表就是创建左子树和右子数的链表再和当前节点连接。
    27.输入一串字符，打印所有可能的字符排序。for(int i=begin; i<len; i++){ swap(s, begin, i); p(s, begin+1, r); swap(s, begin, i); }
    28.找出数组中出现次数超过一半的数字。
    29.求最小的k个数。
    30.连续子数组的求和。
  - 31.从1到n整数中，1出现的次数。
  - 32.把数组排成最小数。
  - 33.按从小到大的顺序求1500个丑数。
    34.第一次只出现一次的字符。
  - 35.求数组中的逆序对的总数。
    36.两个链表第一个公共结点。利用栈。
    37.数字在排序数组中出现的次数。
    38.求二叉树的深度。通过递归求左右子树的深度。