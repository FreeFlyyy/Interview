一、java se
	1.反序列化的类名
		序列化的时候，会将对象的类信息放在序列化的字节中，方便在反序列化时加载相关相关的类。
	2.HashMap
		a).初始的capacity大小
			16，并且HashMap的桶容量始终为2^n，主要是为了求余的方便。
		b).扩容机制
			HashMap中有一个loadFactor，当hashmap当前的元素个数达到了capacity*loadFactory时，便会增加桶的个数。
			桶的个数增加，之前桶里的数据需要重新放置在新的桶中。更进一步的说，这样的机制可以保证桶中的元素不至于过多，而导致链表搜索时间过长。
	3.TreeMap
		a).为什么要用红黑树
			插入删除的旋转次数更少，即效率更高。
	4.为什么要重载equal方法？
		因为Object的equal方法默认是两个对象的引用的比较，意思就是指向同一内存,地址则相等，否则不相等；如果你现在需要利用对象里面的值来判断是否相等，则重载equal方法。
	5.为什么重载hashCode方法
	  一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode
	6.java继承方法调用顺序：
		如果b类继承自a类，在main方法中new出b的对象(不带参数)，那么他执行的顺序是：	
			父类a的类变量赋值-->父类a的静态代码块-->类b的类变量赋值-->类b的静态代码块-->父类a的非静态代码块-->父类a的无参构造函数-->子类b的非静态代码块-->子类b的无参构造函数
二、java ee
	1.DispatchServlet流程
		a).通过请求从handlermapping中获取对应的控制器和拦截器链，mappedHandler = getHandler(processedRequest);
		b).使用handlerAdapter封装控制器，HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
		c).拦截器链处理，mappedHandler.applyPreHandle(processedRequest, response)
		d).执行控制器，得到mv。mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
		e).拦截器处理，applyPostHandle。
		f).主要是对结果mv进行处理，渲染视图。processDispatchResult。
	2.spring aop
		生成代理：通过AopProxyFactory生成代理对象；默认策略是目标类是接口，则使用JDK动态代理，否则使用Cglib。
		织入：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,创建MethodInvocation，调用其proceed方法，触发拦截器链的执行,并执行joinpoint; 如果没有,则直接反射执行joinpoint。
	3.SpringMVC和Struts2的区别
	4.Spring如何解决循环依赖
		让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，
		并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在
		初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），
		尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，
		B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，
		最终A也完成了初始化，长大成人，进去了一级缓存singletonObjects中，由于B拿到了A的对象引用，所以B现在hold住的A对象也蜕变完美了！
	5.Spring配置相关
		1.让spring识别@Scheduled注解  <task:annotation-driven />                                  
		2.定时1s @Scheduled(cron = "0/1 * * * * ?")
		3.<mvc:default-servlet-handler />将静态资源的处理经由Spring MVC框架交回Web应用服务器处理
		4.<mvc:resources />由Spring MVC框架自己处理静态资源
		5.@Transactional配置事务
	6.Spring的事务传播级别
		1） PROPAGATION_REQUIRED ，默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，
			则新建事务执行。
		2）PROPAGATION_SUPPORTS ，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。
		3）PROPAGATION_MANDATORY ， 该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！
		4）PROPAGATION_REQUIRES_NEW ，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。
		5）PROPAGATION_NOT_SUPPORTED ，这当前级别的特点就是上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。
		6）PROPAGATION_NEVER ，PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！
		7）PROPAGATION_NESTED ，该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。
三、oop
	1.面向对象设计的solid原则
		1).单一责任原则(Single responsibility)
			一个类的职责为一个，也只有这个原因会造成类的修改。当类需要承担其他责任时，应该分解该类。
		2).开闭原则(Open close)
			类应该是对扩展开放，对修改封闭的。
		3).里式替换原则(Liskov Substitution)
			子类和父类是is-A关系。
		4).接口分离原则(Interface Segregation)
			面向接口编程。
		5).依赖倒置原则(Dependency Inversion)
			高层模块不应该依赖于底层模块，二者都应该依赖于抽象。
			抽象不应该依赖细节，细节需要依赖抽象。
	2.哪些框架里面用过装饰器模式
		Stream
	3.哪些框架里面用过工厂模式(包括抽象工厂和工厂方法)？
		Spring(抽象工厂)、线程池，数据库连接池。
	4.为什么要使用工厂模式
	5.简单工厂和抽象工厂的区别
	6.面向过程和面向对象的区别
四、jvm
	1.新生代gc的原理(Minor GC)
		新生代gc采用复制-清除算法。jvm给新生代分配了3块空间:survivor1, survivor2, Eden.
		新生对象放置在Eden空间中，当Eden满时将会把Eden和survivor中幸存的对象复制到另一个survivor中，然后将Eden清空。每次经过一次Minor GC将会使仍然幸存的对象年龄加一，达到一定年龄的对象将会转到老年代空间。
	2.full gc的触发时机和原理
		a).System.gc();建议jvm进行full gc，但是并不是立即执行。
		b).当Minor GC发生时，将会保存仍然幸存的对象，当仍然幸存的对象过大时，会向老年代空间申请空间，若老年代空间不够用了，会触发full gc。若仍然不够，则抛出异常。
		c).分配大对象时，会将大对象直接保存到老年代中，若老年代空间不够，会触发一次full gc。
	3.类加载流程
		1).加载，读取class的二进制数据，在内存中。
		2).验证，保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害。
		3).准备，为变量分配内存，并设置类变量的初始化。
		4).解析，将里面可以解析的符号进行解析。
		5).初始化，执行类中static域的赋值和static方法。
	4.如何热替换
		需要利用classloader。
		简单来说，在加载一个类时，需要使用用户自定义类加载器UserClassLoader来进行加载。修改了类的代码后，需要通过字节码生成技术重新生成类的class文件，然后舍去之前的类加载器，并新建一个UserClassLoader来进行加载。以前加载进来的类和类加载器将会被从内存中移除。
		参考jsp的class实时加载方案，每个jsp都将生成对应的java文件并会生成对应的字节码class文件，每个jsp-class文件都会用JasperLoader进行类加载，当jsp-class被修改会新建一个JasperLoader来加载新的jsp-class，而丢弃以前的。
	5.各类引用
		强引用， 是指创建一个对象并把这个对象赋给一个引用变量。强引用有引用变量指向时永远不会被垃圾回收。即使内存不足的时候。
		软引用，当内存空间不足的时候，引用的对象才会gc标记并且清楚。
		弱引用，引用的对象只能活到下次gc。
		虚引用，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
	6.同类名不同jar包的类加载
		jvm 加载包名和类名相同的类时，先加载classpath中jar路径放在前面的，包名类名都相同，那jvm没法区分了，如果使用ide一般情况下是会提示发生冲突而报错，
		若不报错，只有第一个包被引入（在classpath路径下排在前面的包），第二个包会在classloader加载类时判断重复而忽略。
	7.一个大量对象迅速产生又死亡的代码如何优化
五、编程 数据结构与算法
	1.选择法排序
		基本思想是 每次遍历数组选择最小的值，然后将该值放到最前面。
		更进一步，第i次遍历，选择r[i+1]~r[n-1]中的最小值，并与r[i]进行交换，直至全部完毕。
	2.外部排序
		磁盘中可以存储的数据远大于内存，为了对磁盘中的海量数据进行排序，因此要使用外部排序。这里设内存可以放置的数据元素为N个。
		1).简单算法(两路合并)
			读取N个数据到内存中，进行排序并输出到磁盘中。这样可以将磁盘中的数据分为M组，每组N个元素的顺串保存到磁盘中。
			然后可以进行顺串的合并，两两长度为N的顺串合并后得到M/2组长度为2*N的顺串，按同样的方法再次进行排序，直到只有1组顺串为止。
			顺串合并采用归并排序是所用的合并方案。
		2).多路合并
			借鉴上述的方案，在得到初始的M组顺串后，使用k组顺串合并的方案，这样可以减少合并的次数，但是为了得到k个数的最小值会比2路的多花些时间。
		3).多相合并
			多相合并主要是为了节约磁盘空间。不展开。
		4).替换选择
			多路合并的方案需要读入N个元素到内存，然后输出一个长度为N的顺串。后面的合并操作主要受顺串的个数影响。
			为了进一步减小顺串的个数，可以考虑增大一个顺串的长度。
			N个元素读入到内存中并建立一个优先队列，执行一次deleteMin，把最小的元素输出到磁盘中。然后再读入一个元素到内存，若是比刚刚输出的元素大则将其入堆，若是比刚刚的输出元素小，则让它进死区，因为刚刚已经输出了比这个元素大的了，不能输出新加入的元素到磁盘中。
			一直如此，直到队列中没有元素时，便输出了一个顺串。此时死区已满，将死区中的数据重建堆，进行新的顺串输出。
	3.快速排序
		c++的stl采用的排序方法。
		基本思想是选取数组中的一个数，称为枢纽元。将数组中比枢纽元小的数分为1组，比枢纽元大的数分为1组，然后将这两组排序。排序得到两组数，可以直接拼接得到最终排序结果。
		枢纽元的选取方案；三数中值分割法，即选取左端 右端 中心位置上的3个元素的中值作为枢纽元。
	4.最长公共子序列
		最大公共子序列有这么一个特点：两串的结尾符号相同时，那么该符号必定是最大公共子序列的结尾符号。
		设c[i, j]为x1...xi和y1...yj的最大公共子序列的长度，那么：有
		c[i, j] = 0								, if i=0 or j=0
		        = c[i-1, j-1] + 1				, if xi==xj
				= max( c[i-1, j], c[j, i-1] )	, if i,j>0 and xi!=xj
	5.反向链表
		1).递归方案
			Node process(Node parent){
				if(this.next != null){
					Node node = this.next.process(this);	//记录反转后的首节点
					this.next=parent;
					return node; 
				}else{
					this.next=parent;
					return this;
				}
			}
		2).三指针方案
			第一个指针指向当前节点的父节点，第二个指针指向当前节点，第三个指针指向下一个节点，修改第二个指针的节点的next的指向到第一个指针的节点。滑动这3个指针。
	6.数组中最的子数组之和
	7.有一个生成0/1的随机数生成器，生成0的概率是p，生成1的概率是1-p，基于此设计一个随机数生成器，使得产生0/1的概率均为1/2
	8.一个数组中包含了1到1w的不重复数字，找出该数组中不存在的1到1w的两个数字。
	
六、linux
	1.awk命令
		awk是一个强大的文本分析工具。awk将文件逐行读取，以空格为默认的分隔符将每行切片，对切开的部分再进行分析处理。
		相当于awk每次输入的是文本的一行的多个切片，切片之间默认以是原始行字符串进行空格分割得到的。
		awk [选项参数] '<script>' <filename>
		<filename>为要处理的文件
		[选项参数] 是一些awk处理的配置，如设置分隔符，可省。
		这里的<script>的格式为: '{[pattern] <action>}'，这里的[pattern]相当于是个正则匹配，对一行的切片进行一个筛选，可省。action是对一行的切片进行具体的处理。
		如：awk '{print $1,$4}' log.txt， 这里<filename>为log.txt，<action>为print $1, $4。 $1和$4就是对切片的引用，切片的下标从【1】开始。
	2.无法删除文件的原因
		没有写权限。
	3.查看服务器状态
		cat /proc/cpuinfo          查看cpu信息，如每个CPU型号，主频等
		free                       查看内存使用情况
		cat /proc/meminfo          查看详细内存使用情况
		lsblk                      查看硬盘和分区
		lspcl | grep -i 'eth'      查看网卡硬件信息
		ifconfig                       
		netstat -a (all)显示所有选项，默认不显示LISTEN相关
				-t (tcp)仅显示tcp相关选项
				-u (udp)仅显示udp相关选项
				-n 拒绝显示别名，能显示数字的全部转化成数字。
				-l 仅列出有在 Listen (监听) 的服務状态
				-p 显示建立相关链接的程序名
				-r 显示路由信息，路由表
				-e 显示扩展信息，例如uid等
				-s 按各个协议进行统计
				-c 每隔一个固定时间，执行该netstat命令。
		top     top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；
		
七、计算机网络
	1.三次握手
		第一次
		第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
		第二次
		第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
		第三次
		第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
	2.四次挥手
		A发起FIN关闭请求，A端进入FIN_WAIT_1状态。
		B端收到FIN请求后回应ACK, A端进入FIN_WAIT_2状态，B端进入CLOSE_WAIT状态。
		B发起FIN请求，B端进入LAST_ACK状态。
		A端收到FIN请求后回应ACK，A端进入TIME_WAIT等待一段时间后，将进行关闭，B端收到ACK将关闭。
	3.TCP和UDP的区别
		1).TCP
			TCP会进行三次握手和四次握手以确定连接成功。
			对于数据的发送，会将数据缓存，若发送超时会将缓存的数据重新进行发送。
		2).UDP
			UDP不会将待发送数据缓存，而是直接发送出去。UDP速度快，但是可靠性不及TCP。
	4.TCP有哪些确保连接的机制
		1).三次握手 四次挥手
		2).滑动窗口机制协商队列大小实现数据传输
		3).超时重传
		4).CRC校验
		5).对于收到的请求，会进行回应
		6).顺序编号(确保消息顺序)
	5.HTTP头包含哪些内容
		1).请求头常见信息
			Accept-Charset，用于指定客户端接受的字符集
			Accept-Encoding，用于制定客户端可接受的编码
			Accept-Language，用于指定客户端可接受的语言
			Host，请求资源的Internet主机域名和端口号
			User-Agent，客户端的操作系统，浏览器和其他属性告诉服务器
			Connection，当前连接是否需要保持(开启后便是长连接，http服务不会重新发起连接而是使用已经存在的)
			Cookie，保存在浏览器的cookie数据
		2).响应头
			Server，服务器使用的http服务器名称
			Content-Type，告诉浏览器实体正文的内容类型(如json html)
			Content-Encoding，告诉浏览器服务端所采用的压缩编码方式
			Content-Length，告诉浏览器实体正文的长度
			Keep-Alive，告诉浏览器保持连接的时间
	6.http状态码(200 301 302 403 404 500)
		100-199 用于指定客户端应相应的某些动作。 
		200-299 用于表示请求成功。 
		300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 
		400-499 用于指出客户端的错误。 
		500-599 用于支持服务器错误。 
		
		200 : 请求已经成功。
		301 : 重定向。
		302 : 请求的资源现在临时从不同的 URI 响应请求。也是一个重定向。
		403 : 服务器已经理解请求，但是拒绝执行它。
		404 : 请求失败，请求所希望得到的资源未被在服务器上发现。
		500 : 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。
	7.HTTPS
		https服务器，就是服务器有个ssl证书，并且https协议的数据都是经过加密了的。
		简单来说，浏览器将自己的一套加密方案发送给服务器，服务器从中筛选出一组加密算法与hash算法，将自己的身份信息以证书的形式返回给浏览器。浏览器通过这些信息去验证服务器的合法性。
		若是合法，则从证书中获取公钥来进行传输数据的加密。
	8.DNS的原理
		用于解析域名所对应的ip。
		1).浏览器会检查缓存中有没有这个域名解析过IP，如果有直接使用。浏览器域名缓存有大小和时间限制。
		2).浏览器中没有，就会到操作系统的hosts配置文件中查找对应的ip。linux下为/etc/hosts
		3).配置文件中没有，就会到域名服务器中查询，域名服务器为本机的网络配置中的DNS服务器地址。该域名服务器也称为本地DNS服务器(LDNS)。该解析器会缓存域名解析结果，大部分的解析工作在这里就能完成。
		4).LDNS中也没有查找到，LDNS将会到Root Server域名服务器请求解析。Root Server返回LDNS一个所查询域名的主域名服务器(gTLD Server)。gTLD全球只有13台左右，如.com .net等等各自的总域名服务器。
		5).LDNS将会到gTLD Server中查询Name Server域名服务器。Name Server就是该域名注册的服务器，例如在腾讯云的域名提供商申请的域名，那么就有这个域名提供商的服务器来完成解析。
		6).LDNS将会到Name Server中查询，并得到最后的结果。(Name Server可能有多级，因此可能会有多次查询才能得到结果)
		7).将结果返回给本地主机。
	9.cookie、session
		1).cookie
			将和服务器交互的数据保存在浏览器中。数据量过大时，会增大传输延迟。
		2).session
			客户的数据保存在服务器，通过cookie中的sessionid来让服务器知道当前的请求来自哪个浏览器。通常是保存在内存当中。数据量过大时会增大服务器压力。
			因为cookie的数据保存在本地，容易受到编辑，因此session常用来保存一些安全级别较高的数据，比如用户的认证信息等。
		3).session的生命周期
			- 打开浏览器，在浏览器上发送首次请求
			- 服务器会创建一个HttpSession对象，该对象代表一次会话
			- 同时生成HttpSession对象对应的Cookie对象，并且Cookie对象的name是JESSIONID，cookie的value是32位长度的字符串
			- 服务器将cookie 的value和HttpSession对象绑定到session列表中
			- 服务器将cookie发送到浏览器客户端，并且浏览器将cookie保存到缓存中
			- 只要浏览器不关闭，cookie不会消失
			- 当再次发送请求时，浏览器会自动提交缓存当中的cookie给服务器
			- 服务器收到cookie，验证该cookie的name确实是：JESSIONID，然后获取该cooike的value
			- 通过cookie的value去session列表中检索对应的HttpSession对象。
	10.滑动窗口
		（1）TCP连接阶段，双方协商窗口尺寸，同时接收方预留数据缓存区；  
		（2）发送方根据协商的结果，发送符合窗口尺寸的数据字节流，并等待对方的确认；  
		（3）发送方根据确认信息，改变窗口的尺寸，增加或者减少发送未得到确认的字节流中的字节数。调整过程包括：如果出现发送拥塞，发送窗口缩小为原来的一半，同时将超时重传的时间间隔扩大一倍。  
　　	 TCP的窗口机制和确认保证了数据传输的可靠性和流量控制。
	11.超时重传：
		基本原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。 
	12.快速重传：	
		如果发送端接受到3个以上的重复ACK的情况下，就应该意识到，数据丢了，需要重新传递。这个机制是不需要等到重传定时器溢出的，所以叫做快速重传
	11.连接一个网址涉及到的操作
		1).应用层(http)
			- dns
			- cdn，内容分发网络，将网站的静态资源发布到各个cdn服务器，用户获取这些资源的时候将会到最近的服务器去获取，以提高用户访问网站的速度。静态数据以css，js图片，html为主。
			- http，无状态短链接传输协议，将请求头(多个请求行组成)和请求体发送过去，并等待响应(响应头和响应体)
		2).传输层处理(tcp)
			在应用层确定发送域名的ip后(应用层的dns服务)以及需要传输的数据(http数据)，就能通过tcp协议和服务器端的tcp监听socket进行连接了。
			连接采用3次握手，当连接成功时，本地就能通过socket将这些数据发送到服务器端，服务器端也可以发送数据到客户端。
			当连接结束时，将会通过4次挥手断开。
		3).网络层处理(ip)
			解析从当前计算机经过哪些路由器才能到服务器所在的主机。
		4).链路层处理(arp)
			当到了服务器所连接的路由器时，将会通过arp来找到具体的主机ip对应的mac地址，将数据交由对应的主机。
			arp机制:
				每台主机都会在内存中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。
				当源主机需要将数据发送给目标主机时，会首先检查自己ARP列表是否有这个IP对应的MAC，有则直接发送。
				否则发起ARP广播包，该包中包含了源主机地址(mac, ip)以及目标的ip，网络中的所有主机收到该包后会检查目标ip和自己是否一致，若不一致则不做回应。
				和目标ip一致的主机将会刷新下自己的ARP列表(更新源主机ip对应的mac)，然后返回自己的mac给源主机，源主机更新ARP，再传送数据。
	12.PUT通常指定了资源的存放位置，POST的数据存放位置由服务器自己决定
	13.服务器出现大量的timewait连接的原因
		timewait，是首先关闭连接的一方(A)，在发送了最后一个ACK时进入的状态，在该状态下持续2MSL时间，若在这段时间内没有收到另一方(B)的消息，则进入close。
		由于网络问题，可能B发送的FIN会丢失，因此B在小于2MSL的时间下没有收到A的ACK则会重发FIN。
		而A发送了ACK后，由于网络原因，也可能丢失，若丢失了那么B会重发一个FIN到A，这时候A就知道ACK丢失了，就会重发一个FIN到B。
		综上所述，通常情况下连接都是由客户端主动断开的，因此timewait一般会出现在客户端上。
		但是某些服务比如FTP，是服务器接收到了客户端的QUIT命令后，主动发送FIN进行关闭的，因此也可能会出现在服务器上。
		劣势：
			当服务器端存在大量的timewait时，会严重影响并发性能，因为timewait的连接所占用的socket结构并不会释放，而每个socket都会占用一个port。
			因此大量的timewait会消耗系统资源，并且会占尽系统提供的port，导致不得不阻塞用户服务。
		形成原因：
			通常是由于关闭服务由服务器端发起，并且系统的目标是高并发而造成的。这样就会在服务器中存在大量的timewait。
		解决：
			首先，尽量不要使用由服务器关闭socket的服务。
			其次，进行系统配置
			net.ipv4.tcp_tw_reuse = 1
			net.ipv4.tcp_tw_recycle = 1
			简单来说，就是打开系统的TIMEWAIT重用和快速回收。
八、数据库
	1.mysql的数据库引擎
		1).MyISAM
			采用表锁，没有死锁危险，不具备事务功能。使用表时会将整个表的操作上读锁，可以同时读，但是不能同时写或同时读写。读操作大于更新操作时效率较高。
		2).Memory
			将数据保存在内存中。速度快，不能持久化。
		3).InnoDB
			采用行级锁，有死锁危险，采用事务管理。是mysql默认使用的数据库引擎。
	2.索引的结构和劣势
		不同的数据库与数据库引擎实现索引上有区别，对于mysql来说，Innodb的索引采用B+tree。
		1).空间劣势
			每创建一个索引，都要在磁盘中创建一份B+tree结构的索引文件，其key是索引字段，value是对应的主键。若主键字段过程，还会进一步消耗磁盘空间。
		2).增删改劣势
			当增删加一个条目时，会更新涉及到的所有索引文件的b+tree。
			当修改索引值时，也会更新对应的索引的b+tree。
		3).和主键索引的区别
			主键索引也是一个b+tree文件，key是主键，value是该条目的所有数据。普通的索引key是索引字段，value是对应的主键。
	3.crud的基本命令
		1).增: "insert into <table> (...) values (...)"
		2).删: "delete from <table> where ..."
		3).改: "update <table> set ... where ..."
		4).查: "select .. from <table> where ..."
	4.事务的acid
		1).原子性，一个事物是不可分割的最小单元，事务要么成功全部成功，要么全部失败。
		2).一致性，写进数据库与读出的一致。
		3).隔离性，通常来说，一个事务所做的操作在未提交前，对其他事务来说是不可见的。这需要隔离级别【提交读】的支持。
		4).持久性，一旦事务提交，其修改将用于保存到数据库。
	5.事务隔离级别
		1).未提交读
			其他事务未提交的修改，会反应在当前数据中，被称为【脏读】
		2).提交读
			只要其他事务提交，其修改在当前事务是可以得到的。在当前事务中不能保证读取的全一样，因此会造成【不可重复读】。
		3).可重复读
			其他事务提交了所做的修改，不会反应到当前事务中，避免了【不可重复读】。但是其他事务添加的数据会反应到当前事务中，因此会幻读。
		4).可串行化
			事务的操作完全串行化，当开了一个事务时，就不能开其他事务了。其他事务会阻塞到当前事务提交。
	6.查询优化
		0.不要在满足查询条件的查询范围比较大的情况下使用索引,不适合键值较少的列（重复数据较多的列）。
		1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
		2.尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。
		4.前导模糊查询不能利用索引(like '%XX'或者like '%XX%')
		5.MySQL主要提供2种方式的索引：B-Tree索引，Hash索引。哈希索引只能做等于查找,B树支持范围查找。
		6.在创建复合索引时， 应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。
		8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为:select id from t where num=100*2
		11.应尽可能的让字段顺序与索引顺序相一致。
		14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。
		15. 索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。
		17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
		18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
		20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。
		21.避免频繁创建和删除临时表，以减少系统表资源的消耗。
		22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。
		23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
		24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。
		29.尽量避免大事务操作，提高系统并发能力。
		30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
	7.sql文(group by ， order by ， distinct ， is Null ， join...)
	8.分布式mysql，主从mysql
		分布式部署mysql的主要目的是为了提升性能和高可用。
		提升性能主要是利用【读写分离】技术来缓解读的压力，对于写的压力需要采用分区技术。
		高可用主要是利用【双master】技术。
		1).读写分离
			将主数据(master)备份多个从数据库(slave)。由master接收客户端的请求，并通过负载均衡将读请求交给slave完成。若是写请求则将请求的语句写入二进制日志，并更新master。
			一致性问题：由于读写分离，需要将更新的数据传给slave来保证一致性。
				- 同步，master的更新操作会等待更新所有的slave，所有的slave都保持同步后master才会返回客户端。redis的一致性解决方案。
				- 异步，master的更新操作不会等待更新slave，而是另开一个后台进程将更新操作交给slave。主从mysql的默认方案。
				- 半异步，master的更新操作会去更新一个slave，该slave同步后便返回客户端，不等待其他slave。类似zookeeper的一致性解决方案，只不过zookeeper是等待半数结点以上的同步。
				异步和半异步，都会造成slave滞后于master的数据，客户端需要进行额外的操作来保证从slave取出的数据是最新的。
				比如zookeeper是客户端发送sync指令要求所连接的slave同步到master的状态。
				mysql也是和zookeeper类似的同步机制：客户端获得数据库当前的binlog位置(通俗理解就是最新的更新操作编号)，在读取slave时会等待slave已经到了binlog的位置。
				由于master-slave的异步更新，对于客户端读取实时的数据造成了一些困难，常用的处理策略有：
					# 从业务上降低客户端对于数据实时性的要求的基础上，对于绕不开的事实读取，就通过获得master数据库当前binlog位置，来使slave在到达binlog时才读取slave的数据。
					# 将读请求分发到状态较新的slave上。
		2).高可用
			有【热备份】和【双master】的高可用方案，一般采用双maser。双maser又分两种：
				- active-active:
					这样的方案有利于分割地理位置不同的区域，不同的区域由不同的master提供服务，而master之间会随时保持同步。
					这样的方案比较严重的缺陷是：两个master更新相同的字段会造成冲突，并且两个master不一致的时候会造成崩溃。
				- active-passive:
					这类方案类似hdfs的namenode高可用方案，有两个master，一个master是活跃的，一个是备份的。
					两个master同步，一般会通过master的操作更新备份的master，或是将数据存放在共享磁盘空间中。
					这样的方案可能会出现split-brain的问题，需要kill掉原active。
	9.分区表
		分区表是一种粗粒度,简易的索引策略,适用于大数据的过滤场景。
	10.来自客户端大量的修改数据库的请求，数据库的修改也是大量条目的
		数据库读写分离+水平拆分+垂直拆分
		- 读写分离
			主要是减轻读压力。使用master-slave的结构，由master接收所有的请求，将都请求转发给slave，由slave执行。
			对于写请求，将写入master，而后master将异步更新slave。
		- 垂直拆分
			读写压力都能减轻。主要是分析业务，将相对之间独立的表给拆分开来放到不同的数据库主机上，这样由不同的数据库主机来处理不同的业务。
			主要是需要注意，轻微依赖的表也可以分开到不同的数据库主机上，由于仍然存在以来，因此存在跨数据库主机查询的问题。
		- 水平拆分
			读写压力都能减轻，但主要是减轻数据量过大时的写压力。主要是将数据量过大的表数据，保存到多个数据库主机上。更具体说就是表结构不变，但是数据拆分到不同主机上存储。
			当单个主机上存储过多数据，会导致btree过深，调整树将会花费更多时间。
			通过水平拆分，缩减表中的数据项，可以节约树操作。另一方面，读写操作都将会负载均衡到各个主机上去，因此读写压力也会降低。
			水平拆分存在主键不能按传统方式递增的问题，可以将表的主键值放在redis中，交由它进行递增。数据库主机的确定可以通过sid+hash的机制，将指定sid的数据放到某个主机上。		
	11.mysql锁：
		页级:引擎 BDB。
		表级:引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行
		行级:引擎 INNODB ， 单独的一行记录加锁
		表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许
		行级, 仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。
		页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录		
	12.Exists与In效率分析
		In:是把外表和内表做Hash 连接，而exists 是对外表作loop 循环，每次loop循环再对内表进行查询。
		   当查询两个表的大小相当时，用In 和 exists差别不大。
		   如果两个表中一个表较小，一个表较大，那么子查询表大的用exists,子查询表小的用In，效率会高的。
           也就是说 IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况，这样效率会高的
	13.Not in 和Not Exists 的 效率
       如果查询语句使用了Not In,那么内外表全部进行扫描，没有乃至索引
       Not Exist用到子表中的索引进行查询，所以无论两个表中哪个表大，Not exists 都要比Not in 要快
		   
		
九、分布式与网络编程
	1.redis
		1).redis应用场景
		2).redis和sql的区别
	2.nginx
		1).支持的负载均衡算法
		2).节点宕机处理
			a).不含nginx服务的节点宕机
				nginx有健康监测机制，而该机制又有3种。
				最简单的一种是：每当一个请求到来，会转发到一个处理节点，若该节点达到默认超出时间未响应，则向另一台处理节点转发。默认超时时间是1分钟。
			b).nginx服务的节点宕机
				nginx自己不能处理，需要使用keepalived才能配置为高可用nginx服务器。
				nginx+keepalived的工作模式类似hdfs的高可用工作模式，是一种active-standby模式。也就是由两台nginx提供负载均衡服务，但是任一时刻下只有一台提供服务，另一台作为备份。
				这种模式也叫双机热备份。
	3.负载均衡算法
		1).轮询法
			将请求按顺序的分配到节点上，不关心节点的连接数和负载情况。
		2).随机法
			将每次请求到来生成要给随机数，然后按随机数将请求分配到节点上。总体来说和轮询法效果差不多。
		3).源地址hash法
			均衡器获得请求的ip地址，并生产ip地址的hash，将hash取模得到后的值作为其对应的连接节点。ip不变时每次映射到同一个节点进行处理，也没有session共享的问题。
		4).最少连接法
			均衡器记录目前所有活跃的连接，把下一个新请求发送给含有最少连接数的节点。不同的节点性能不同，因此连接数其实并不能真实反应节点的负载压力。
		5).最快响应法
			均衡器记录每个节点的网络响应时间，将下一个新请求发送给响应时间最短的节点。这种方法要求均衡器主动探测各节点状态。
		6).加权轮询法
			均衡器初始化时按照各节点的权值来生成一个序列，权值大的节点在序列中出现的次数对应较多，当请求来时便是在这个序列中进行轮询来选择处理的节点。
	4.RPC原理
	　1.调用客户端句柄；执行传送参数
	　　2.调用本地系统内核发送网络消息
	　　3.消息传送到远程主机
	　　4.服务器句柄得到消息并取得参数
	　　5.执行远程过程
	　　6.执行的过程将结果返回服务器句柄
	　　7.服务器句柄返回结果，调用远程系统内核
	　　8.消息传回本地主机
	　　9.客户句柄由内核接收消息
	　　10.客户接收句柄返回的数据
	5.RPC与RMI的区别与联系
	（1）RPC 跨语言，而 RMI只支持Java。
	（2）RMI 调用远程对象方法，允许方法返回 Java 对象以及基本数据类型，而RPC 不支持对象的概念，传送到 RPC 服务的消息由外部数据表示 (External Data Representation, XDR) 语言表示，
	    这种语言抽象了字节序类和数据类型结构之间的差异。只有由 XDR 定义的数据类型才能被传递， 可以说 RMI 是面向对象方式的 Java RPC 。
	（3）在方法调用上，RMI中，远程接口使每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口上，那么这个新方法就不能被RMI客户方所调用。
		 在RPC中，当一个请求到达RPC服务器时，这个请求就包含了一个参数集和一个文本值，通常形成“classname.methodname”的形式。这就向RPC服务器表明，被请求的方法在为 “classname”的类中，
		 名叫“methodname”。然后RPC服务器就去搜索与之相匹配的类和方法，并把它作为那种方法参数类型的输入。这里的参数类型是与RPC请求中的类型是匹配的。一旦匹配成功，这个方法就被调用了，
		 其结果被编码后返回客户方。
	5.kafka
	6.mr
		1).map任务处理
			1.1 读取输入文件内容，将文件分解为多个split(默认一个块就是一个split，这样可以节约集群的传输带宽)，解析成key、value对。对输入文件的每一行的起始偏移，解析成key、value对。每一个键值对调用一次map函数。
			1.2 写自己的逻辑，对输入的key、value处理，转换成新的key、value输出。
			1.3 对输出的key、value进行分区。
			1.4 对不同分区的数据，按照key进行排序、分组。相同key的value放到一个集合中。
			1.5 (可选)分组后的数据进行归约(combiner)，节约节点中的传输带宽。
		2).reduce任务处理
			2.1 对多个map任务的输出，按照不同的分区，通过网络copy到不同的reduce节点。
			2.2 对多个map任务的输出进行合并、排序。写reduce函数自己的逻辑，对输入的key、values处理，转换成新的key、value输出。
			2.3 把reduce的输出保存到文件中。
	7.elasticSearch
	8.cap
		数据一致性(consistency)：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据，对调用者而言数据具有强一致性(strong consistency) (又叫原子性 atomic、线性一致性 linearizable consistency)[5]
		服务可用性(availability)：所有读写请求在一定时间内得到响应，可终止、不会一直等待
		分区容错性(partition-tolerance)：在网络分区的情况下，被分隔的节点仍能正常对外服务
		在某时刻如果满足AP，分隔的节点同时对外服务但不能相互通信，将导致状态不一致，即不能满足C；
		如果满足CP，网络分区的情况下为达成C，请求只能一直等待，即不满足A；
		如果要满足CA，在一定时间内要达到节点状态一致，要求不能出现网络分区，则不能满足P。
十、并发编程
	1.synchronized和lock的区别
		这里的lock主要指ReentrantLock而不是jvm的lock指令。
		简单来说，ReentrantLock 和 synchronized相比具有相同的并发性和语义，除此外还包含中断锁等候和定时锁等候，即阻塞的线程在指定时间内依然无法获得锁，那么就会自动放弃该锁。
		更进一步，synchronized是在jvm层面的实现，ReentrantLock是在代码上实现的，因此无法自动释放锁，要显示的使用lock()和unlock()。高并发下，ReentrantLock的性能通常更好。
	2.volatile的作用
		volatile为了保障与主内存交互的原子性，并且可以取消重排序优化。因此具有可见性。
		volatile声明的变量操作，都会从主内存中取数据，并将数据同步到主内存。非volatile变量，使用的是线程内存。
	3.Java创建线程的三种方式
		1).继承Runnable接口
		2).继承Thread类
		3).通过 Callable 和 Future 创建线程
			- 通过ExecutorService提交Callable的方式(本质上这种方法并不是创建线程，而是提交任务，线程已经创建了的)
			- 通过FutureTask封装Callable，再由Thread封装FutureTask。FutureTask本质上是一个Runnable，更具体说是Runnable Future的子类。
	4.并发协调
		1).sleep()
			使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步快，
			其他线程仍然不能访问共享数据。注意该方法要捕捉异常。
		2).join()
			join()方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。注意该方法也需要捕捉异常。
		3).yield()
			该方法与sleep()类似，只是不能由用户指定暂停多长时间，并且yield（）方法只能让同优先级的线程有执行的机会。
		4).wait()和notify()、notifyAll()
			wait()方法使当前线程暂停执行并释放对象锁标示，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中。当调用notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，
			只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。
	5.如何解决死锁问题
十一、操作系统
	1.进程和线程的区别
	2.进程间如何通讯
		# 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
		# 有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
		# 信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
		# 消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
		# 信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
		# 共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
		# 套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
	3.线程间如何通讯
		# 锁机制：包括互斥锁、条件变量、读写锁
			*互斥锁提供了以排他方式防止数据结构被并发修改的方法。
			*读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
			*条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
		# 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
		# 信号机制(Signal)：类似进程间的信号处理
			线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。
	4.进程的堆栈的区别
	5.多线程的优势
		1).相比单进程的优势
			- 提升可伸缩性，采用了多线程可以充分发挥多核的优势，并且合理的多线程利用前提下，随着cpu资源的增加，吞吐量可以进一步提升。
			- 时间片轮询，将时间分配给多个线程去使用，可以提升ui的流畅程度。
		2).相比多进程的优势
			- 轻量级，因此线程的创建销毁，上下文切换的成本都远低于多进程。
			- 内存共享，因此多线程之间更容易共享内容，更容易协调工作。
十二、安全
	1.常用加密算法
		异或加密、DES、AES、RSA、椭圆加密、混沌加密。
	2.对称加密和非对称加密
		1).对称加密
			即传统的加密方式，加密解密使用同一个密钥。DES和AES是用的较多的对称加密方案。DES现在已经不够安全了。
		2).非对称加密(密钥对加密)
			即常见的用公钥私钥的加密方法，常用的有rsa加密和椭圆加密。
			非对称加密主要使用密钥对来完成操作，公钥加密的数据可以使用私钥解密，私钥加密的数据可以使用公钥解密。使用场景:
			a).传统加密传输
				A向B发送秘密信息，B将生成密钥对并将公钥发送给A，A使用公钥进行加密，然后将加密数据发送给B。
				https就是采用这也的机制，浏览器将数据使用公钥进行加密发送给服务器，由服务器来进行解密。
			b).身份认证
				A证实B的身份，B将生成密钥对将公钥发送给A，而后由B发送到A的操作均是通过私钥加密的，A将使用公钥将解密这个信息，若无法解析则无法证实B的身份，拒绝A的数据。
				github采用的就是该机制，github是角色A，本地仓库是角色B。github会使用所有的公钥来解析本地仓库发送过去的数据，若均无法解析则拒绝本地仓库的请求。
十三、NIO
	1.NIO主要有哪些类
		1) Buffer
			Buffer抽象代表了一个有限容量的数据容器，其本质是一个数组。由指针指示了哪里存放数据以及从哪里读取数据。
			ByteBuffer buffer = new ByteBuffer.allocate(CAPACITY);
		2) Channel
			Channel的实例代表了一个与设备的连接，通过channel进输入和输出操作。对于TCP而言有两种：ServerSocketChannel和SocketChannel。
			channel可以设置为阻塞或者非阻塞：socket.configureBlocking(false);
			ServerSocketChannel在执行accept()方法时，若有连接请求在等待，则返回SocketChannel实例。
		3) Selector
			Selector的实例中可以注册多个Channel的实例，当Channel的实例有事件触发时，将会在Selector中进行记录。channel.register(selector, event);
			通过selector.select()方法，可以返回已有记录的Channel与其对应的事件。
			可以注册的事件有:
				- SelectionKey.OP_ACCEPT
					这个是ServerSocketChannel的事件。当serverChannel接收到客户端socket的连接请求时，将会触发该事件。
				- SelectionKey.OP_READ
					这个是SocketChannel的事件，当socket的读缓冲区中存在数据时，将会触发该事件。
				- SelectionKey.OP_WRITE
					这个是SocketChannel的事件按，当socket的写缓冲区没有满时，将会触发改事件。
			与Selector配合使用的还有SelectionKey类，该类封装了Channel和一个事件。Selector的select()方法将会返回一组SelectiongKey，里面有发生事件的Channel及其事件本身。
	2.举出一个NIO的使用流程范例
		nio主要在服务器端使用:
			private void service() throws Exception{
				Selector selector = Selector.open();
				
				ServerSocketChannel serverChannel = ServerSocketChannel.open();
				serverChannel.socket().bind(new InetSocketAddress(port));
				serverChannel.configureBlocking(false);
				serverChannel.register(selector, SelectionKey.OP_ACCEPT);
				
				System.out.println("service start...");
				while(true){
					if(selector.select(100) == 0){continue;}		//避免永久阻塞

					Iterator<SelectionKey> keyIter = selector.selectedKeys().iterator();
					while(keyIter.hasNext()){
						SelectionKey key = keyIter.next();
						if(key.isAcceptable()){
							handleAccept(key);
						}else if(key.isReadable()){	
							handleRead(key);
						}else if(key.isWritable()){
							handleWrite(key);
						}
						keyIter.remove();
					}
				}
			}

			protected void handleAccept(SelectionKey key) throws IOException{
				SocketChannel clntSocket = ((ServerSocketChannel)key.channel()).accept();
				clntSocket.configureBlocking(false);
				clntSocket.register(key.selector(), SelectionKey.OP_READ, new ByteArrayOutputStream());	//注册读客户端socket的事件
			}

十五、其他
	1.服务器优化
		1).缓存机制
			缓存机制符合分形几何学，即每个缓存系统的局部都又可以看成一个缓存系统。
			整体： 浏览器 <---> 前端cache <---> 服务器
			mysql局部 : 请求 <---> innodb_buffer_prol存放热点数据 <---> MySQL内部数据
			mysql内部 : 内存 <---> L1 Cache <---> L2 Cache <---> L3 Cache <---> 硬盘
		2).负载均衡
			- 重定向进行负载均衡，简单，局部小范围使用。
			- DNS进行负载均衡，可以给一个域名配置多个ip地址，以此来进行负载均衡。当系统宕机，很难修改dns，而且不够灵活。
			- nginx反向代理，易于控制，但是nginx服务器的宕机会带来灾难性影响，并且超高并发环境下nginx服务器将成为瓶颈。
			- 多级负载均衡，设计多个nginx进行负载均衡器，而client到nginx的负载均衡是交由dns负责。
				client ---dns负载均衡---> nginx ---负载均衡---> 业务系统
			- 读写分离，数据库采用mater-slave的方式，master将读操作传递给slave，由slave负责，这本质上就是一种负载均衡。写操作在master上进行，master会将操作更新到slave。
			- 数据库水平拆分，水平拆分是将一张表的数据保存在多个服务器上，这样可以缓解update操作的压力。因为若将数据全部放在一个主机上，会导致索引的b树很深。因此update操作会带来很大的性能影响。
		3).共享资源的并发优化
			- 锁分段，根据读写的范围，将共享资源分为多个部分，每次只针对该读写的部分进行上锁。行级锁就是一种这样的机制，不用给整个表上锁。
			- 读写锁，【并发读】不上锁，【并发读写】或者【并发写】才上锁。当有读和写操作在等待时，根据读优先模式和写优先模式，选择优先进行读操作或是写操作。
			- 乐观锁，本质上就是CAS+版本号控制机制。（CAS本身就是一种乐观锁，但是需要依赖版本号才能避免ABA问题。）
		4).垂直拆分
			垂直拆分的含义就是根据业务功能，将相对独立的模块分割到不同的服务器上。
			- 业务模块拆分，主要是将相对独立的业务拆分到不同的服务器上。
			- 数据库垂直拆分，主要是将相互独立的表拆分到不同的数据库主机上。
		5).高可用
			- nginx高可用，每个nginx都应该使用备份的nginx以免宕机。
			- 数据库高可用。
			- 缓存系统高可用。
			- 业务系统高可用。（其实就是引入负载均衡）
十六、C/C++
	1.c和c++的区别
	2.c++中如何实现多态