一、java se
	1.反序列化的类名
		序列化的时候，会将对象的类信息放在序列化的字节中，方便在反序列化时加载相关相关的类。
	2.HashMap
		a).初始的大小
		b).是否线程安全
		c).读操作是线程安全的吗
	3.TreeMap
		a).为什么要用红黑树
	4.ArrayList
	5.LinkedList
二、java ee
	1.DispatchServlet流程
		a).通过请求从handlermapping中获取对应的控制器和拦截器链，mappedHandler = getHandler(processedRequest);
		b).使用handlerAdapter封装控制器，HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
		c).拦截器链处理，mappedHandler.applyPreHandle(processedRequest, response)
		d).执行控制器，得到mv。mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
		e).拦截器处理，applyPostHandle。
		f).主要是对结果mv进行处理，渲染视图。processDispatchResult。
	2.spring aop
		生成代理：通过AopProxyFactory生成代理对象；默认策略是目标类是接口，则使用JDK动态代理，否则使用Cglib。
		织入：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,创建MethodInvocation，调用其proceed方法，触发拦截器链的执行,并执行joinpoint; 如果没有,则直接反射执行joinpoint。
	3.SpringMVC和Struts2的区别
三、oop
	1.面向对象设计的solid原则
		1).单一责任原则(Single responsibility)
			一个类的职责为一个，也只有这个原因会造成类的修改。当类需要承担其他责任时，应该分解该类。
		2).开闭原则(Open close)
			类应该是对扩展开放，对修改封闭的。
		3).里式替换原则(Liskov Substitution)
			子类和父类是is-A关系。
		4).接口分离原则(Interface Segregation)
			面向接口编程。
		5).依赖倒置原则(Dependency Inversion)
			高层模块不应该依赖于底层模块，二者都应该依赖与抽象。
			抽象不应该依赖细节，细节需要依赖抽象。
	2.哪些框架里面用过装饰器模式
		Stream
	3.哪些框架里面用过工厂模式(包括抽象工厂和工厂方法)？
		Spring(抽象工厂)、线程池，数据库连接池。
	4.为什么要使用工厂模式
四、jvm
	1.新生代gc的原理(Minor GC)
		新生代gc采用复制-清除算法。jvm给新生代分配了3块空间:survivor1, survivor2, Eden.
		新生对象放置在Eden空间中，当Eden满时将会把Eden和survivor中幸存的对象复制到另一个survivor中，然后将Eden清空。每次经过一次Minor GC将会使仍然幸存的对象年龄加一，达到一定年龄的对象将会转到老年代空间。
	2.full gc的触发时机和原理
		a).System.gc();建议jvm进行full gc，但是并不是立即执行。
		b).当Minor GC发生时，将会保存仍然幸存的对象，当仍然幸存的对象过大时，会向老年代空间申请空间，若老年代空间不够用了，会触发full gc。若仍然不够，则抛出异常。
		c).分配大对象时，会将大对象直接保存到老年代中，若老年代空间不够，会触发一次full gc。
	3.类加载流程
		1).加载，读取class的二进制数据，在内存中。
		2).验证，检查类的数据是否满足java的要求。
		3).准备，
		4).解析，将里面可以解析的符号进行解析。
		5).初始化，执行类中static域的赋值和static方法。
	4.如何热替换
		需要利用classloader。
		简单来说，在加载一个类时，需要使用用户自定义类加载器UserClassLoader来进行加载。修改了类的代码后，需要通过字节码生成技术重新生成类的class文件，然后舍去之前的类加载器，并新建一个UserClassLoader来进行加载。以前加载进来的类和类加载器将会被从内存中移除。
		参考jsp的class实时加载方案，每个jsp都将生成对应的java文件并会生成对应的字节码class文件，每个jsp-class文件都会用JasperLoader进行类加载，当jsp-class被修改会新建一个JasperLoader来加载新的jsp-class，而丢弃以前的。
	5.软引用和弱引用的区别
		软引用，当内存空间不足的时候，引用的对象才会gc标记并且清楚。
		弱引用，引用的对象只能活到下次gc。
	6.同类名不同jar包的类加载
		这种情况要使用不同的类加载器去加载同类名的类。
		若使用的唯一的类加载器，有两种情况：1）报错。2）忽略后面需要加载的类。
	7.一个大量对象迅速产生又死亡的代码如何优化
五、数据结构与算法
	1.选择法排序
		基本思想是 每次遍历数组选择最小的值，然后将该值放到最前面。
		更进一步，第i次遍历，选择r[i+1]~r[n-1]中的最小值，并与r[i]进行交换，直至全部完毕。
	2.外部排序
		磁盘中可以存储的数据远大于内存，为了对磁盘中的海量数据进行排序，因此要使用外部排序。这里设内存可以放置的数据元素为N个。
		1).简单算法(两路合并)
			读取N个数据到内存中，进行排序并输出到磁盘中。这样可以将磁盘中的数据分为M组，每组N个元素的顺串保存到磁盘中。
			然后可以进行顺串的合并，两两长度为N的顺串合并后得到M/2组长度为2*N的顺串，按同样的方法再次进行排序，直到只有1组顺串为止。
			顺串合并采用归并排序是所用的合并方案。
		2).多路合并
			借鉴上述的方案，在得到初始的M组顺串后，使用k组顺串合并的方案，这样可以减少合并的次数，但是为了得到k个数的最小值会比2路的多花些时间。
		3).多相合并
			多相合并主要是为了节约磁盘空间。不展开。
		4).替换选择
			多路合并的方案需要读入N个元素到内存，然后输出一个长度为N的顺串。后面的合并操作主要受顺串的个数影响。
			为了进一步减小顺串的个数，可以考虑增大一个顺串的长度。
			N个元素读入到内存中并建立一个优先队列，执行一次deleteMin，把最小的元素输出到磁盘中。然后再读入一个元素到内存，若是比刚刚输出的元素大则将其入堆，若是比刚刚的输出元素小，则让它进死区，因为刚刚已经输出了比这个元素大的了，不能输出新加入的元素到磁盘中。
			一直如此，直到队列中没有元素时，便输出了一个顺串。此时死区已满，将死区中的数据重建堆，进行新的顺串输出。
	3.快速排序
		c++的stl采用的排序方法。
		基本思想是选取数组中的一个数，称为枢纽元。将数组中比枢纽元小的数分为1组，比枢纽元大的数分为1组，然后将这两组排序。排序得到两组数，可以直接拼接得到最终排序结果。
		枢纽元的选取方案；三数中值分割法，即选取左端 右端 中心位置上的3个元素的中值作为枢纽元。
	4.最长公共子序列
		最大公共子序列有这么一个特点：两串的结尾符号相同时，那么该符号必定是最大公共子序列的结尾符号。
		设c[i, j]为x1...xi和y1...yj的最大公共子序列的长度，那么：有
		c[i, j] = 0								, if i=0 or j=0
		        = c[i-1, j-1] + 1				, if xi==xj
				= max( c[i-1, j], c[j, i-1] )	, if i,j>0 and xi!=xj
六、linux
	1.awk命令
	2.无法删除文件的原因 -> 没有写权限。
	3.查看服务器状态
七、计算机网络
	1.三次握手
		客户端发送请求报文(SYN=1, seq=client_isn), client_isn是由客户端生成的序列号。
		服务端接收到请求报文后，将返回一个ACK报文(SYN=1, seq=server_isn, ack=client_isn+1)，server_isn是由服务器端生成的序列号。
		客户端收到ACK报文后，再返回一个ACK报文(SYN=0, seq=client_isn+1, ack=server_isn+1)
	2.四次挥手
		A发起FIN关闭请求，A端进入FIN_WAIT_1状态。
		B端收到FIN请求后回应ACK, A端进入FIN_WAIT_2状态，B端进入CLOSE_WAIT状态。
		B发起FIN请求，B端进入LAST_ACK状态。
		A端收到FIN请求后回应ACK，A端进入TIME_WAIT等待一段时间后，将进行关闭，B端收到ACK将关闭。
	3.TCP和UDP的区别
		1).TCP
			面向连接的协议，在数据传输前需要通过三次握手建立可靠的连接，通过四次挥手来断开连接。
			对系统资源要求较多。
			tcp会保证数据的正确性和顺序。
		2).UDP
			非连接的协议，需要传输时便将其传输过去并尽可能快的放入网络，需要接收的时候从队列中获取数据。
			对系统资源要求较少。
			udp不可靠，可能丢包，并且不保证数据顺序。
	4.TCP有哪些确保连接的机制
		1).三次握手
		2).滑动窗口机制协商队列大小实现数据传输
		3).超时重传
		4).CRC校验
		5).对于收到的请求，会进行回应
	5.HTTP头包含哪些内容
		1).请求头常见信息
			Accept-Charset，用于指定客户端接受的字符集
			Accept-Encoding，用于制定客户端可接受的编码
			Accept-Language，用于指定客户端可接受的语言
			Host，请求资源的Internet主机域名和端口号
			User-Agent，客户端的操作系统，浏览器和其他属性告诉服务器
			Connection，当前连接是否需要保持(开启后便是长连接，http服务不会重新发起连接而是使用已经存在的)
			Cookie，保存在浏览器的cookie数据
		2).响应头
			Server，服务器使用的http服务器名称
			Content-Type，告诉浏览器实体正文的内容类型(如json html)
			Content-Encoding，告诉浏览器服务端所采用的压缩编码方式
			Content-Length，告诉浏览器实体正文的长度
			Keep-Alive，告诉浏览器保持连接的时间
	6.http状态码(200 301 302 403 404 500)
		100-199 用于指定客户端应相应的某些动作。 
		200-299 用于表示请求成功。 
		300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 
		400-499 用于指出客户端的错误。 
		500-599 用于支持服务器错误。 
		
		200 : 请求已经成功。
		301 : 重定向。
		302 : 请求的资源现在临时从不同的 URI 响应请求。也是一个重定向。
		403 : 服务器已经理解请求，但是拒绝执行它。
		404 : 请求失败，请求所希望得到的资源未被在服务器上发现。
		500 : 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。
	7.HTTPS
		https服务器，就是服务器有个ssl证书，并且https协议的数据都是经过加密了的。
		简单来说，浏览器将自己的一套加密方案发送给服务器，服务器从中筛选出一组加密算法与hash算法，将自己的身份信息以证书的形式返回给浏览器。浏览器通过这些信息去验证服务器的合法性。
		若是合法，则从证书中获取公钥来进行传输数据的加密。
	8.DNS的原理
		用于解析域名所对应的ip。
		1).浏览器会检查缓存中有没有这个域名解析过IP，如果有直接使用。浏览器域名缓存有大小和时间限制。
		2).浏览器中没有，就会到操作系统的hosts配置文件中查找对应的ip。linux下位/etc/hosts
		3).配置文件中没有，就会到域名服务器中查询，域名服务器为本机的网络配置中的DNS服务器地址。该域名服务器也称为本地DNS服务器(LDNS)。该解析器会缓存域名解析结果，大部分的解析工作在这里就能完成。
		4).LDNS中也没有查找到，LDNS将会到Root Server域名服务器请求解析。Root Server返回LDNS一个所查询域名的主域名服务器(gTLD Server)。gTLD全球只有13台左右，如.com .net等等各自的总域名服务器。
		5).LDNS将会到gTLD Server中查询Name Server域名服务器。Name Server就是该域名注册的服务器，例如在腾讯云的域名提供商申请的域名，那么就有这个域名提供商的服务器来完成解析。
		6).LDNS将会到Name Server中查询，并得到最后的结果。(Name Server可能有多级，因此可能会有多次查询才能得到结果)
		7).将结果返回给本地主机。
	9.cookie、session
		1).cookie
			将和服务器交互的数据保存在浏览器中。数据量过大时，会增大传输延迟。
		2).session
			客户的数据保存在服务器，通过cookie中的sessionid来让服务器知道当前的请求来自哪个浏览器。通常是保存在内存当中。数据量过大时会增大服务器压力。
			因为cookie的数据保存在本地，容易受到编辑，因此session常用来保存一些安全级别较高的数据，比如用户的认证信息等。
	10.滑动窗口
		（1）TCP连接阶段，双方协商窗口尺寸，同时接收方预留数据缓存区；  
		（2）发送方根据协商的结果，发送符合窗口尺寸的数据字节流，并等待对方的确认；  
		（3）发送方根据确认信息，改变窗口的尺寸，增加或者减少发送未得到确认的字节流中的字节数。调整过程包括：如果出现发送拥塞，发送窗口缩小为原来的一半，同时将超时重传的时间间隔扩大一倍。  
　　	 TCP的窗口机制和确认保证了数据传输的可靠性和流量控制。
	11.超时重传：
		基本原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。 
	12.快速重传：	
		如果发送端接受到3个以上的重复ACK的情况下，就应该意识到，数据丢了，需要重新传递。这个机制是不需要等到重传定时器溢出的，所以叫做快速重传
	13.连接一个网址涉及到的操作
八、数据库
	1.mysql的数据库引擎
		1).MyISAM
			采用表锁，没有死锁危险，不具备事务功能。使用表时会将整个表的操作上读锁，可以同时读，但是不能同时写或同时读写。读操作大于更新操作时效率较高。
		2).Memory
			将数据保存在内存中。速度快，不能持久化。
		3).InnoDB
			采用行级锁，有死锁危险，采用事务管理。是mysql默认使用的数据库引擎。
	2.索引的结构和劣势
		不同的数据库与数据库引擎实现索引上有区别，对于mysql来说，Innodb的索引采用B+tree。
		1).空间劣势
			每创建一个索引，都要在磁盘中创建一份B+tree结构的索引文件，其key是索引字段，value是对应的主键。若主键字段过程，还会进一步消耗磁盘空间。
		2).增删改劣势
			当增删加一个条目时，会更新涉及到的所有索引文件的b+tree。
			当修改索引值时，也会更新对应的索引的b+tree。
		3).和主键索引的区别
			主键索引也是一个b+tree文件，key是主键，value是该条目的所有数据。普通的索引key是索引字段，value是对应的主键。
	3.crud的基本命令
		1).增: "insert into <table> (...) values (...)"
		2).删: "delete from <table> where ..."
		3).改: "update <table> set ... where ..."
		4).查: "select .. from <table> where ..."
	4.事务的acid
		1).原子性，一个事物是不可分割的最小单元，事务要么成功全部成功，要么全部失败。
		2).一致性，。
		3).隔离性，通常来说，一个事务所做的操作在未提交前，对其他事务来说是不可见的。这需要隔离级别【提交读】的支持。
		4).持久性，一旦事务提交，其修改将用于保存到数据库。
	5.事务隔离级别
		1).未提交读
			其他事务未提交的修改，会反应在当前数据中，被称为【脏读】
		2).提交读
			只要其他事务提交，其修改在当前事务是可以得到的。在当前事务中不能保证读取的全一样，因此会造成【不可重复读】。
		3).可重复读
			其他事务提交了所做的修改，不会反应到当前事务中，避免了【不可重复读】。但是其他事务添加的数据会反应到当前事务中，因此会【幻读】。
		4).可串行化
			事务的操作完全串行化，当开了一个事务时，就不能开其他事务了。其他事务会阻塞到当前事务提交。
	6.提高效率的sql用法
	7.超大数据查询优化
	8.sql文(group by ， order by ， distinct ， is Null ， join...)
	9.分布式mysql，主从mysql
九、分布式与网络编程
	1.redis
	2.ngnix
	3.负载均衡算法
		1).轮询法
			将请求按顺序的分配到节点上，不关心节点的连接数和负载情况。
		2).随机法
			将每次请求到来生成要给随机数，然后按随机数将请求分配到节点上。总体来说和轮询法效果差不多。
		3).源地址hash法
			均衡器获得请求的ip地址，并生产ip地址的hash，将hash取模得到后的值作为其对应的连接节点。ip不变时每次映射到同一个节点进行处理，也没有session共享的问题。
		4).最少连接法
			均衡器记录目前所有活跃的连接，把下一个新请求发送给含有最少连接数的节点。不同的节点性能不同，因此连接数其实并不能真实反应节点的负载压力。
		5).最快响应法
			均衡器记录每个节点的网络响应时间，将下一个新请求发送给响应时间最短的节点。这种方法要求均衡器主动探测各节点状态。
		6).加权轮询法
			均衡器初始化时按照各节点的权值来生成一个序列，权值大的节点在序列中出现的次数对应较多，当请求来时便是在这个序列中进行轮询来选择处理的节点。
	4.RPC原理
	5.kafka
	6.mr
	7.elasticSearch
十、并发编程
	1.synchronized和lock的区别
		这里的lock主要指ReentrantLock而不是jvm的lock指令。
		简单来说，ReentrantLock 和 synchronized相比具有相同的并发性和语义，除此外还包含中断锁等候和定时锁等候，即阻塞的线程在指定时间内依然无法获得锁，那么就会自动放弃该锁。
		更进一步，synchronized是在jvm层面的实现，ReentrantLock是在代码上实现的，因此无法自动释放锁，要显示的使用lock()和unlock()。高并发下，ReentrantLock的性能通常更好。
	2.volatile的作用
		volatile为了保障与主内存交互的原子性，并且可以取消重排序优化。因此具有可见性。
		volatile声明的变量操作，都会从主内存中取数据，并将数据同步到主内存。非volatile变量，使用的是线程内存。
十一、操作系统
	1.进程和线程的区别
	2.进程间如何通讯
	3.线程间如何通讯
	4.进程的堆栈的区别
	5.进程和线程的执行力度的区别(这个问题问的是啥我都没弄懂)
十二、安全
	1.常用加密算法
		异或加密、DES、AES、RSA、椭圆加密、混沌加密。
	2.对称加密和非对称加密
		1).对称加密
			即传统的加密方式，加密解密使用同一个密钥。DES和AES是用的较多的对称加密方案。DES现在已经不够安全了。
		2).非对称加密(密钥对加密)
			即常见的用公钥私钥的加密方法，常用的有rsa加密和椭圆加密。
			非对称加密主要使用密钥对来完成操作，公钥加密的数据可以使用私钥解密，私钥加密的数据可以使用公钥解密。使用场景:
			a).传统加密传输
				A向B发送秘密信息，B将生成密钥对并将公钥发送给A，A使用公钥进行加密，然后将加密数据发送给B。
				https就是采用这也的机制，浏览器将数据使用公钥进行加密发送给服务器，由服务器来进行解密。
			b).身份认证
				A证实B的身份，B将生成密钥对将公钥发送给A，而后由B发送到A的操作均是通过私钥加密的，A将使用公钥将解密这个信息，若无法解析则无法证实B的身份，拒绝A的数据。
				github采用的就是该机制，github是角色A，本地仓库是角色B。github会使用所有的公钥来解析本地仓库发送过去的数据，若均无法解析则拒绝本地仓库的请求。